{"version":3,"sources":["../../src/models/GitTree.js"],"names":["parseBuffer","buffer","_entries","cursor","length","space","indexOf","nullchar","mode","slice","toString","path","oid","push","GitTree","constructor","entries","isBuffer","Array","isArray","map","x","sha","Object","assign","Error","from","tree","render","entry","type","join","toObject","concat","replace","encoding","match","n","parseInt","Symbol","iterator"],"mappings":"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","file":"GitTree.js","sourcesContent":["//@flow\nimport {Buffer} from 'buffer'\n\nfunction parseBuffer (buffer) {\n  let _entries = []\n  let cursor = 0\n  while (cursor < buffer.length) {\n    let space = buffer.indexOf(32, cursor)\n    // TODO: assert space > -1\n    let nullchar = buffer.indexOf(0, cursor)\n    // TODO: assert nullchar > -1\n    let mode = buffer.slice(cursor, space).toString('utf8')\n    if (mode === '40000') mode = '040000' // makes it line up neater in printed output\n    let path = buffer.slice(space + 1, nullchar).toString('utf8')\n    let oid = buffer.slice(nullchar + 1, nullchar + 21).toString('hex')\n    cursor = nullchar + 21\n    _entries.push({mode, path, oid})\n  }\n  return _entries\n}\n\nexport default class GitTree {\n  constructor (entries) {\n    if (Buffer.isBuffer(entries)) {\n      this._entries = parseBuffer(entries)\n    } else if (Array.isArray(entries)) {\n      this._entries = entries.map(x => (!x.oid && x.sha) ? Object.assign(x, {oid: x.sha}) : x)\n    } else {\n      throw new Error('invalid type passed to GitTree constructor')\n    }\n  }\n  static from (tree) {\n    return new GitTree(tree)\n  }\n  render () {\n    return this._entries.map(entry => `${entry.mode} ${entry.type} ${entry.oid}    ${entry.path}`).join('\\n')\n  }\n  toObject () {\n    return Buffer.concat(this._entries.map(entry => {\n      let mode = Buffer.from(entry.mode.replace(/^0/,''))\n      let space = Buffer.from(' ')\n      let path = Buffer.from(entry.path, {encoding: 'utf8'})\n      let nullchar = Buffer.from([0])\n      let oid = Buffer.from(entry.oid.match(/../g).map(n => parseInt(n, 16)))\n      return Buffer.concat([mode, space, path, nullchar, oid])\n    }))\n  }\n  entries () {\n    return this._entries\n  }\n  *[Symbol.iterator] () {\n    for (let entry of this._entries) {\n      yield entry\n    }\n  }\n}\n"]}